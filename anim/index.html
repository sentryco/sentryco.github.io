<!doctype html>
<html lang="en"><!-- The wrapper, front and subpage use this wrapper file, most pages uses this wrapper -->
	<head>
	  <meta charset="utf-8">
	  <meta name="viewport" content="width=device-width" initial-scale=1.0>
	  <link rel="stylesheet" href="/main.css"><!--  we prepend base url so we have a common root -->
	  <title>Sentinel</title>

	</head>
	<body> <!-- website html code -->
		<header class="header show-on-scroll">
		<img src="images/pizza.jpg" class="inline-photo show-on-scroll">
	</body>
</html>
<!--
	1. To set up our requestAnimationFrame method we’ll apply it to a variable. This way we are able to have a fallback function for browsers that don’t yet support it.
	2. Here we’re saying that scroll should be the window.requestAnimationFrame method, or (if this isn’t available), use this simple function that waits one-sixtieth of a second before calling the callback.
	3. This will look for all elements with class show-on-scroll and return them as an array we can loop through.
	4. We begin by setting up the function loop. This is a function we want to loop through all the elements and check if they’re visible. We do this using the forEach method. For each of the show-on-scroll elements found this loop will check if it’s in the viewport, and if so, add the class is-visible. Otherwise it’ll remove the class.
	5. Lastly we want to keep firing this function so we’ll make use of our requestAnimationFrame helper we set up earlier, and pass this function as a callback. This means that as soon as requestAnimationFrame allows us, it’ll repeat this function and update classes as needed. As it stands, this won’t do much yet. We need to kick it off by calling the loop function.
	Note: There’s one bit missing. In the loop function we’re calling a method isElementInViewport. Unfortunately this isn’t a browser method, we’ll have to write that one ourselves. Here’s a handy one I grabbed from Stack Overflow.
	note:  Thankfully requestAnimationFrame solves these issues. It’s a method that we can use to repeatedly check our page to see if elements are visible, while making sure we don’t overload the browser by checking thousands of times per second. It does this by limiting how often the callback is executed to either the screen’s refresh rate or 60 times per second.
-->
<script>
	// document.getElementById("body").innerHTML = "Hello JavaScript!";
	var scroll = window.requestAnimationFrame || function(callback){ window.setTimeout(callback, 1000/60)};
	var elementsToShow = document.querySelectorAll('.show-on-scroll');
	function loop() {
	  elementsToShow.forEach(function (element) {
	    if (isElementInViewport(element)) {
	      element.classList.add('is-visible');
	    } else {
	      element.classList.remove('is-visible');
	    }
	  })
	  scroll(loop);
	}
	loop();
	// Helper function
	const callback = function(entries) {
	  entries.forEach(entry => {
	    entry.target.classList.toggle("is-visible");
	  });
	};
	const observer = new IntersectionObserver(callback);
	const targets = document.querySelectorAll(".show-on-scroll");
	targets.forEach(function(target) {
	  observer.observe(target);
	});
 </script>
